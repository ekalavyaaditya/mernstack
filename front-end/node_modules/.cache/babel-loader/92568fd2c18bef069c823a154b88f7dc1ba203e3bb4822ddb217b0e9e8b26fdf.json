{"ast":null,"code":"/**\n * Represents octree data structure\n *\n * https://en.wikipedia.org/wiki/Octree\n */\nvar Bounds3 = require('./lib/bounds3.js');\nvar TreeNode = require('./lib/treeNode.js');\nvar EmptyRegion = new Bounds3();\nvar asyncFor = require('rafor');\nmodule.exports = createTree;\nfunction createTree(options) {\n  options = options || {};\n  var noPoints = [];\n  var root;\n  var originalArray;\n  var api = {\n    /**\n     * Initializes tree asynchronously. Very useful when you have millions\n     * of points and do not want to block rendering thread for too long.\n     *\n     * @param {number[]} points array of points for which we are building the\n     * tree. Flat sequence of (x, y, z) coordinates. Array length should be\n     * multiple of 3.\n     *\n     * @param {Function=} doneCallback called when tree is initialized. The\n     * callback will be called with single argument which represent current\n     * tree.\n     */\n    initAsync: initAsync,\n    /**\n     * Synchronous version of `initAsync()`. Should only be used for small\n     * trees (less than 50-70k of points).\n     *\n     * @param {number[]} points array of points for which we are building the\n     * tree. Flat sequence of (x, y, z) coordinates. Array length should be\n     * multiple of 3.\n     */\n    init: init,\n    /**\n     * Gets bounds of the root node. Bounds are represented by center of the\n     * node (x, y, z) and `half` attribute - distance from the center to an\n     * edge of the root node.\n     */\n    bounds: getBounds,\n    /**\n     * Fires a ray from `rayOrigin` into `rayDirection` and collects all points\n     * that lie in the octants intersected by the ray.\n     *\n     * This method implements An Efficient Parametric Algorithm for Octree Traversal\n     * described in http://wscg.zcu.cz/wscg2000/Papers_2000/X31.pdf\n     *\n     * @param {Vector3} rayOrigin x,y,z coordinates where ray starts\n     * @param {Vector3} rayDirection normalized x,y,z direction where ray shoots.\n     * @param {number+} near minimum distance from the ray origin. 0 by default.\n     * @param {number+} far maximum length of the ray. POSITIVE_INFINITY by default\n     *\n     * @return {Array} of indices in the source array. Each index represnts a start\n     * of the x,y,z triplet of a point, that lies in the intersected octant.\n     */\n    intersectRay: intersectRay,\n    /**\n     * Once you have collected points from the octants intersected by a ray\n     * (`intersectRay()` method), it may be worth to query points from the surrouning\n     * area.\n     */\n    intersectSphere: intersectSphere,\n    /**\n     * Gets root node of the tree\n     */\n    getRoot: getRoot\n  };\n  return api;\n  function getRoot() {\n    return root;\n  }\n  function intersectSphere(cx, cy, cz, r) {\n    if (!root) {\n      // Most likely we are not initialized yet\n      return noPoints;\n    }\n    var indices = [];\n    var r2 = r * r;\n    root.query(indices, originalArray, intersectCheck, preciseCheck);\n    return indices;\n\n    // http://stackoverflow.com/questions/4578967/cube-sphere-intersection-test\n    function intersectCheck(candidate) {\n      var dist = r2;\n      var half = candidate.half;\n      if (cx < candidate.x - half) dist -= sqr(cx - (candidate.x - half));else if (cx > candidate.x + half) dist -= sqr(cx - (candidate.x + half));\n      if (cy < candidate.y - half) dist -= sqr(cy - (candidate.y - half));else if (cy > candidate.y + half) dist -= sqr(cy - (candidate.y + half));\n      if (cz < candidate.z - half) dist -= sqr(cz - (candidate.z - half));else if (cz > candidate.z + half) dist -= sqr(cz - (candidate.z + half));\n      return dist > 0;\n    }\n    function preciseCheck(x, y, z) {\n      return sqr(x - cx) + sqr(y - cy) + sqr(z - cz) < r2;\n    }\n  }\n  function sqr(x) {\n    return x * x;\n  }\n  function intersectRay(rayOrigin, rayDirection, near, far) {\n    if (!root) {\n      // Most likely we are not initialized yet\n      return noPoints;\n    }\n    if (near === undefined) near = 0;\n    if (far === undefined) far = Number.POSITIVE_INFINITY;\n    // we save as squar, to avoid expensive sqrt() operation\n    near *= near;\n    far *= far;\n    var indices = [];\n    root.query(indices, originalArray, intersectCheck, farEnough);\n    return indices.sort(byDistanceToCamera);\n    function intersectCheck(candidate) {\n      // using http://wscg.zcu.cz/wscg2000/Papers_2000/X31.pdf\n      var half = candidate.half;\n      var t1 = (candidate.x - half - rayOrigin.x) / rayDirection.x,\n        t2 = (candidate.x + half - rayOrigin.x) / rayDirection.x,\n        t3 = (candidate.y + half - rayOrigin.y) / rayDirection.y,\n        t4 = (candidate.y - half - rayOrigin.y) / rayDirection.y,\n        t5 = (candidate.z - half - rayOrigin.z) / rayDirection.z,\n        t6 = (candidate.z + half - rayOrigin.z) / rayDirection.z,\n        tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)),\n        tmin;\n      if (tmax < 0) return false;\n      tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));\n      return tmin <= tmax && tmin <= far;\n    }\n    function farEnough(x, y, z) {\n      var dist = (x - rayOrigin.x) * (x - rayOrigin.x) + (y - rayOrigin.y) * (y - rayOrigin.y) + (z - rayOrigin.z) * (z - rayOrigin.z);\n      return near <= dist && dist <= far;\n    }\n    function byDistanceToCamera(idx0, idx1) {\n      var x0 = rayOrigin[idx0];\n      var y0 = rayOrigin[idx0 + 1];\n      var z0 = rayOrigin[idx0 + 2];\n      var dist0 = (x0 - rayOrigin.x) * (x0 - rayOrigin.x) + (y0 - rayOrigin.y) * (y0 - rayOrigin.y) + (z0 - rayOrigin.z) * (z0 - rayOrigin.z);\n      var x1 = rayOrigin[idx1];\n      var y1 = rayOrigin[idx1 + 1];\n      var z1 = rayOrigin[idx1 + 2];\n      var dist1 = (x1 - rayOrigin.x) * (x1 - rayOrigin.x) + (y1 - rayOrigin.y) * (y1 - rayOrigin.y) + (z1 - rayOrigin.z) * (z1 - rayOrigin.z);\n      return dist0 - dist1;\n    }\n  }\n  function init(points) {\n    verifyPointsInvariant(points);\n    originalArray = points;\n    root = createRootNode(points);\n    for (var i = 0; i < points.length; i += 3) {\n      root.insert(i, originalArray, 0);\n    }\n  }\n  function initAsync(points, doneCallback) {\n    verifyPointsInvariant(points);\n    var tempRoot = createRootNode(points);\n    asyncFor(points, insertToRoot, doneInternal, {\n      step: 3\n    });\n    function insertToRoot(element, i) {\n      tempRoot.insert(i, points, 0);\n    }\n    function doneInternal() {\n      originalArray = points;\n      root = tempRoot;\n      if (typeof doneCallback === 'function') {\n        doneCallback(api);\n      }\n    }\n  }\n  function verifyPointsInvariant(points) {\n    if (!points) throw new Error('Points array is required for quadtree to work');\n    if (typeof points.length !== 'number') throw new Error('Points should be array-like object');\n    if (points.length % 3 !== 0) throw new Error('Points array should consist of series of x,y,z coordinates and be multiple of 3');\n  }\n  function getBounds() {\n    if (!root) return EmptyRegion;\n    return root.bounds;\n  }\n  function createRootNode(points) {\n    // Edge case deserves empty region:\n    if (points.length === 0) {\n      var empty = new Bounds3();\n      return new TreeNode(empty);\n    }\n\n    // Otherwise let's figure out how big should be the root region\n    var minX = Number.POSITIVE_INFINITY;\n    var minY = Number.POSITIVE_INFINITY;\n    var minZ = Number.POSITIVE_INFINITY;\n    var maxX = Number.NEGATIVE_INFINITY;\n    var maxY = Number.NEGATIVE_INFINITY;\n    var maxZ = Number.NEGATIVE_INFINITY;\n    for (var i = 0; i < points.length; i += 3) {\n      var x = points[i],\n        y = points[i + 1],\n        z = points[i + 2];\n      if (x < minX) minX = x;\n      if (x > maxX) maxX = x;\n      if (y < minY) minY = y;\n      if (y > maxY) maxY = y;\n      if (z < minZ) minZ = z;\n      if (z > maxZ) maxZ = z;\n    }\n\n    // Make bounds square:\n    var side = Math.max(Math.max(maxX - minX, maxY - minY), maxZ - minZ);\n    // since we need to have both sides inside the area, let's artificially\n    // grow the root region:\n    side += 2;\n    minX -= 1;\n    minY -= 1;\n    minZ -= 1;\n    var half = side / 2;\n    var bounds = new Bounds3(minX + half, minY + half, minZ + half, half);\n    return new TreeNode(bounds);\n  }\n}","map":{"version":3,"names":["Bounds3","require","TreeNode","EmptyRegion","asyncFor","module","exports","createTree","options","noPoints","root","originalArray","api","initAsync","init","bounds","getBounds","intersectRay","intersectSphere","getRoot","cx","cy","cz","r","indices","r2","query","intersectCheck","preciseCheck","candidate","dist","half","x","sqr","y","z","rayOrigin","rayDirection","near","far","undefined","Number","POSITIVE_INFINITY","farEnough","sort","byDistanceToCamera","t1","t2","t3","t4","t5","t6","tmax","Math","min","max","tmin","idx0","idx1","x0","y0","z0","dist0","x1","y1","z1","dist1","points","verifyPointsInvariant","createRootNode","i","length","insert","doneCallback","tempRoot","insertToRoot","doneInternal","step","element","Error","empty","minX","minY","minZ","maxX","NEGATIVE_INFINITY","maxY","maxZ","side"],"sources":["C:/Users/INSP 5430 I5/OneDrive/Desktop/mernstack/front-end/node_modules/yaot/index.js"],"sourcesContent":["/**\n * Represents octree data structure\n *\n * https://en.wikipedia.org/wiki/Octree\n */\nvar Bounds3 = require('./lib/bounds3.js');\nvar TreeNode = require('./lib/treeNode.js');\nvar EmptyRegion = new Bounds3();\nvar asyncFor = require('rafor');\n\nmodule.exports = createTree;\n\nfunction createTree(options) {\n  options = options || {};\n  var noPoints = [];\n\n  var root;\n  var originalArray;\n  var api = {\n    /**\n     * Initializes tree asynchronously. Very useful when you have millions\n     * of points and do not want to block rendering thread for too long.\n     *\n     * @param {number[]} points array of points for which we are building the\n     * tree. Flat sequence of (x, y, z) coordinates. Array length should be\n     * multiple of 3.\n     *\n     * @param {Function=} doneCallback called when tree is initialized. The\n     * callback will be called with single argument which represent current\n     * tree.\n     */\n    initAsync: initAsync,\n\n    /**\n     * Synchronous version of `initAsync()`. Should only be used for small\n     * trees (less than 50-70k of points).\n     *\n     * @param {number[]} points array of points for which we are building the\n     * tree. Flat sequence of (x, y, z) coordinates. Array length should be\n     * multiple of 3.\n     */\n    init: init,\n\n    /**\n     * Gets bounds of the root node. Bounds are represented by center of the\n     * node (x, y, z) and `half` attribute - distance from the center to an\n     * edge of the root node.\n     */\n    bounds: getBounds,\n\n    /**\n     * Fires a ray from `rayOrigin` into `rayDirection` and collects all points\n     * that lie in the octants intersected by the ray.\n     *\n     * This method implements An Efficient Parametric Algorithm for Octree Traversal\n     * described in http://wscg.zcu.cz/wscg2000/Papers_2000/X31.pdf\n     *\n     * @param {Vector3} rayOrigin x,y,z coordinates where ray starts\n     * @param {Vector3} rayDirection normalized x,y,z direction where ray shoots.\n     * @param {number+} near minimum distance from the ray origin. 0 by default.\n     * @param {number+} far maximum length of the ray. POSITIVE_INFINITY by default\n     *\n     * @return {Array} of indices in the source array. Each index represnts a start\n     * of the x,y,z triplet of a point, that lies in the intersected octant.\n     */\n    intersectRay: intersectRay,\n\n    /**\n     * Once you have collected points from the octants intersected by a ray\n     * (`intersectRay()` method), it may be worth to query points from the surrouning\n     * area.\n     */\n    intersectSphere: intersectSphere,\n\n    /**\n     * Gets root node of the tree\n     */\n    getRoot: getRoot\n  };\n\n  return api;\n\n  function getRoot() {\n    return root;\n  }\n\n  function intersectSphere(cx, cy, cz, r) {\n    if (!root) {\n      // Most likely we are not initialized yet\n      return noPoints;\n    }\n    var indices = [];\n    var r2 = r * r;\n    root.query(indices, originalArray, intersectCheck, preciseCheck);\n    return indices;\n\n    // http://stackoverflow.com/questions/4578967/cube-sphere-intersection-test\n    function intersectCheck(candidate) {\n      var dist = r2;\n      var half = candidate.half;\n      if (cx < candidate.x - half) dist -= sqr(cx - (candidate.x - half));\n      else if (cx > candidate.x + half) dist -= sqr(cx - (candidate.x + half));\n\n      if (cy < candidate.y - half) dist -= sqr(cy - (candidate.y - half));\n      else if (cy > candidate.y + half) dist -= sqr(cy - (candidate.y + half));\n\n      if (cz < candidate.z - half) dist -= sqr(cz - (candidate.z - half));\n      else if (cz > candidate.z + half) dist -= sqr(cz - (candidate.z + half));\n      return dist > 0;\n    }\n\n    function preciseCheck(x, y, z) {\n      return sqr(x - cx) + sqr(y - cy) + sqr(z - cz) < r2;\n    }\n  }\n\n  function sqr(x) {\n    return x * x;\n  }\n\n  function intersectRay(rayOrigin, rayDirection, near, far) {\n    if (!root) {\n      // Most likely we are not initialized yet\n      return noPoints;\n    }\n\n    if (near === undefined) near = 0;\n    if (far === undefined) far = Number.POSITIVE_INFINITY;\n    // we save as squar, to avoid expensive sqrt() operation\n    near *= near;\n    far *= far;\n\n    var indices = [];\n    root.query(indices, originalArray, intersectCheck, farEnough);\n    return indices.sort(byDistanceToCamera);\n\n    function intersectCheck(candidate) {\n      // using http://wscg.zcu.cz/wscg2000/Papers_2000/X31.pdf\n      var half = candidate.half;\n      var t1 = (candidate.x - half - rayOrigin.x) / rayDirection.x,\n        t2 = (candidate.x + half - rayOrigin.x) / rayDirection.x,\n        t3 = (candidate.y + half - rayOrigin.y) / rayDirection.y,\n        t4 = (candidate.y - half - rayOrigin.y) / rayDirection.y,\n        t5 = (candidate.z - half - rayOrigin.z) / rayDirection.z,\n        t6 = (candidate.z + half - rayOrigin.z) / rayDirection.z,\n        tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)),\n        tmin;\n\n      if (tmax < 0) return false;\n\n      tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));\n      return tmin <= tmax && tmin <= far;\n    }\n\n    function farEnough(x, y, z) {\n      var dist = (x - rayOrigin.x) * (x - rayOrigin.x) +\n                 (y - rayOrigin.y) * (y - rayOrigin.y) +\n                 (z - rayOrigin.z) * (z - rayOrigin.z);\n      return near <= dist && dist <= far;\n    }\n\n    function byDistanceToCamera(idx0, idx1) {\n      var x0 = rayOrigin[idx0];\n      var y0 = rayOrigin[idx0 + 1];\n      var z0 = rayOrigin[idx0 + 2];\n      var dist0 = (x0 - rayOrigin.x) * (x0 - rayOrigin.x) +\n                  (y0 - rayOrigin.y) * (y0 - rayOrigin.y) +\n                  (z0 - rayOrigin.z) * (z0 - rayOrigin.z);\n\n      var x1 = rayOrigin[idx1];\n      var y1 = rayOrigin[idx1 + 1];\n      var z1 = rayOrigin[idx1 + 2];\n\n      var dist1 = (x1 - rayOrigin.x) * (x1 - rayOrigin.x) +\n                  (y1 - rayOrigin.y) * (y1 - rayOrigin.y) +\n                  (z1 - rayOrigin.z) * (z1 - rayOrigin.z);\n      return dist0 - dist1;\n    }\n  }\n\n  function init(points) {\n    verifyPointsInvariant(points);\n    originalArray = points;\n    root = createRootNode(points);\n    for (var i = 0; i < points.length; i += 3) {\n      root.insert(i, originalArray, 0);\n    }\n  }\n\n  function initAsync(points, doneCallback) {\n    verifyPointsInvariant(points);\n\n    var tempRoot = createRootNode(points);\n    asyncFor(points, insertToRoot, doneInternal, { step: 3 });\n\n    function insertToRoot(element, i) {\n      tempRoot.insert(i, points, 0);\n    }\n\n    function doneInternal() {\n      originalArray = points;\n      root = tempRoot;\n      if (typeof doneCallback === 'function') {\n        doneCallback(api);\n      }\n    }\n  }\n\n  function verifyPointsInvariant(points) {\n    if (!points) throw new Error('Points array is required for quadtree to work');\n    if (typeof points.length !== 'number') throw new Error('Points should be array-like object');\n    if (points.length % 3 !== 0) throw new Error('Points array should consist of series of x,y,z coordinates and be multiple of 3');\n  }\n\n  function getBounds() {\n    if (!root) return EmptyRegion;\n    return root.bounds;\n  }\n\n  function createRootNode(points) {\n    // Edge case deserves empty region:\n    if (points.length === 0) {\n      var empty = new Bounds3();\n      return new TreeNode(empty);\n    }\n\n    // Otherwise let's figure out how big should be the root region\n    var minX = Number.POSITIVE_INFINITY;\n    var minY = Number.POSITIVE_INFINITY;\n    var minZ = Number.POSITIVE_INFINITY;\n    var maxX = Number.NEGATIVE_INFINITY;\n    var maxY = Number.NEGATIVE_INFINITY;\n    var maxZ = Number.NEGATIVE_INFINITY;\n    for (var i = 0; i < points.length; i += 3) {\n      var x = points[i],\n        y = points[i + 1],\n        z = points[i + 2];\n      if (x < minX) minX = x;\n      if (x > maxX) maxX = x;\n      if (y < minY) minY = y;\n      if (y > maxY) maxY = y;\n      if (z < minZ) minZ = z;\n      if (z > maxZ) maxZ = z;\n    }\n\n    // Make bounds square:\n    var side = Math.max(Math.max(maxX - minX, maxY - minY), maxZ - minZ);\n    // since we need to have both sides inside the area, let's artificially\n    // grow the root region:\n    side += 2;\n    minX -= 1;\n    minY -= 1;\n    minZ -= 1;\n    var half = side / 2;\n\n    var bounds = new Bounds3(minX + half, minY + half, minZ + half, half);\n    return new TreeNode(bounds);\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}