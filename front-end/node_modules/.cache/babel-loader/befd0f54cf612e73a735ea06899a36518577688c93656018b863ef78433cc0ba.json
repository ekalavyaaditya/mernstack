{"ast":null,"code":"module.exports = asyncFor;\n\n/**\n * Iterates over array in async manner. This function attempts to maximize\n * number of elements visited within single event loop cycle, while at the\n * same time tries to not exceed a time threshold allowed to stay within\n * event loop.\n *\n * @param {Array} array which needs to be iterated. Array-like objects are OK too.\n * @param {VisitCalback} visitCallback called for every element within for loop.\n * @param {DoneCallback} doneCallback called when iterator has reached end of array.\n * @param {Object=} options - additional configuration:\n * @param {number} [options.step=1] - default iteration step\n * @param {number} [options.maxTimeMS=8] - maximum time (in milliseconds) which\n *   iterator should spend within single event loop.\n * @param {number} [options.probeElements=5000] - how many elements should iterator\n *   visit to measure its iteration speed.\n */\nfunction asyncFor(array, visitCallback, doneCallback, options) {\n  var start = 0;\n  var elapsed = 0;\n  options = options || {};\n  var step = options.step || 1;\n  var maxTimeMS = options.maxTimeMS || 8;\n  var pointsPerLoopCycle = options.probeElements || 5000;\n  // we should never block main thread for too long...\n  setTimeout(processSubset, 0);\n  function processSubset() {\n    var finish = Math.min(array.length, start + pointsPerLoopCycle);\n    var i = start;\n    var timeStart = new Date();\n    for (i = start; i < finish; i += step) {\n      visitCallback(array[i], i, array);\n    }\n    if (i < array.length) {\n      elapsed += new Date() - timeStart;\n      start = i;\n      pointsPerLoopCycle = Math.round(start * maxTimeMS / elapsed);\n      setTimeout(processSubset, 0);\n    } else {\n      doneCallback(array);\n    }\n  }\n}","map":{"version":3,"names":["module","exports","asyncFor","array","visitCallback","doneCallback","options","start","elapsed","step","maxTimeMS","pointsPerLoopCycle","probeElements","setTimeout","processSubset","finish","Math","min","length","i","timeStart","Date","round"],"sources":["C:/Users/INSP 5430 I5/OneDrive/Desktop/mernstack/front-end/node_modules/rafor/index.js"],"sourcesContent":["module.exports = asyncFor;\n\n/**\n * Iterates over array in async manner. This function attempts to maximize\n * number of elements visited within single event loop cycle, while at the\n * same time tries to not exceed a time threshold allowed to stay within\n * event loop.\n *\n * @param {Array} array which needs to be iterated. Array-like objects are OK too.\n * @param {VisitCalback} visitCallback called for every element within for loop.\n * @param {DoneCallback} doneCallback called when iterator has reached end of array.\n * @param {Object=} options - additional configuration:\n * @param {number} [options.step=1] - default iteration step\n * @param {number} [options.maxTimeMS=8] - maximum time (in milliseconds) which\n *   iterator should spend within single event loop.\n * @param {number} [options.probeElements=5000] - how many elements should iterator\n *   visit to measure its iteration speed.\n */\nfunction asyncFor(array, visitCallback, doneCallback, options) {\n  var start = 0;\n  var elapsed = 0;\n  options = options || {};\n  var step = options.step || 1;\n  var maxTimeMS = options.maxTimeMS || 8;\n  var pointsPerLoopCycle = options.probeElements || 5000;\n  // we should never block main thread for too long...\n  setTimeout(processSubset, 0);\n\n  function processSubset() {\n    var finish = Math.min(array.length, start + pointsPerLoopCycle);\n    var i = start;\n    var timeStart = new Date();\n    for (i = start; i < finish; i += step) {\n      visitCallback(array[i], i, array);\n    }\n    if (i < array.length) {\n      elapsed += (new Date() - timeStart);\n      start = i;\n\n      pointsPerLoopCycle = Math.round(start * maxTimeMS/elapsed);\n      setTimeout(processSubset, 0);\n    } else {\n      doneCallback(array);\n    }\n  }\n}\n"],"mappings":"AAAAA,MAAM,CAACC,OAAO,GAAGC,QAAQ;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQA,CAACC,KAAK,EAAEC,aAAa,EAAEC,YAAY,EAAEC,OAAO,EAAE;EAC7D,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,OAAO,GAAG,CAAC;EACfF,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAIG,IAAI,GAAGH,OAAO,CAACG,IAAI,IAAI,CAAC;EAC5B,IAAIC,SAAS,GAAGJ,OAAO,CAACI,SAAS,IAAI,CAAC;EACtC,IAAIC,kBAAkB,GAAGL,OAAO,CAACM,aAAa,IAAI,IAAI;EACtD;EACAC,UAAU,CAACC,aAAa,EAAE,CAAC,CAAC;EAE5B,SAASA,aAAaA,CAAA,EAAG;IACvB,IAAIC,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACd,KAAK,CAACe,MAAM,EAAEX,KAAK,GAAGI,kBAAkB,CAAC;IAC/D,IAAIQ,CAAC,GAAGZ,KAAK;IACb,IAAIa,SAAS,GAAG,IAAIC,IAAI,CAAC,CAAC;IAC1B,KAAKF,CAAC,GAAGZ,KAAK,EAAEY,CAAC,GAAGJ,MAAM,EAAEI,CAAC,IAAIV,IAAI,EAAE;MACrCL,aAAa,CAACD,KAAK,CAACgB,CAAC,CAAC,EAAEA,CAAC,EAAEhB,KAAK,CAAC;IACnC;IACA,IAAIgB,CAAC,GAAGhB,KAAK,CAACe,MAAM,EAAE;MACpBV,OAAO,IAAK,IAAIa,IAAI,CAAC,CAAC,GAAGD,SAAU;MACnCb,KAAK,GAAGY,CAAC;MAETR,kBAAkB,GAAGK,IAAI,CAACM,KAAK,CAACf,KAAK,GAAGG,SAAS,GAACF,OAAO,CAAC;MAC1DK,UAAU,CAACC,aAAa,EAAE,CAAC,CAAC;IAC9B,CAAC,MAAM;MACLT,YAAY,CAACF,KAAK,CAAC;IACrB;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}