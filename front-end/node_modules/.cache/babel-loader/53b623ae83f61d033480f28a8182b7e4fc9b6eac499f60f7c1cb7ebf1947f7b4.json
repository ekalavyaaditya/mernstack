{"ast":null,"code":"import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Vector2, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n};\n\n// support multiple method names for backwards threejs compatibility\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nconst _box$1 = new THREE$2.Box3();\nconst _vector = new THREE$2.Vector3();\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box$1.setFromBufferAttribute(end);\n      this.boundingBox.union(_box$1);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n  toJSON() {// todo\n  }\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n}\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n}\nLineMaterial.prototype.isLineMaterial = true;\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nconst _start = new THREE.Vector3();\nconst _end = new THREE.Vector3();\nconst _start4 = new THREE.Vector4();\nconst _end4 = new THREE.Vector4();\nconst _ssOrigin = new THREE.Vector4();\nconst _ssOrigin3 = new THREE.Vector3();\nconst _mvMatrix = new THREE.Matrix4();\nconst _line = new THREE.Line3();\nconst _closestPoint = new THREE.Vector3();\nconst _box = new THREE.Box3();\nconst _sphere = new THREE.Sphere();\nconst _clipToWorldVector = new THREE.Vector4();\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n    _ssOrigin.applyMatrix4(projectionMatrix);\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n    _ssOrigin3.copy(_ssOrigin);\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n      _end4.fromBufferAttribute(instanceEnd, i);\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n        _end4.lerp(_start4, t);\n      } // clip space\n\n      _start4.applyMatrix4(projectionMatrix);\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n      _start4.multiplyScalar(1 / _start4.w);\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n      _line.start.z = 0;\n      _line.end.copy(_end4);\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n        _line.end.fromBufferAttribute(instanceEnd, i);\n        _line.start.applyMatrix4(matrixWorld);\n        _line.end.applyMatrix4(matrixWorld);\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n}\nLineSegments2.prototype.LineSegments2 = true;\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n    super.setPositions(points);\n    return this;\n  }\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n    super.setColors(colors);\n    return this;\n  }\n  fromLine(line) {\n    var geometry = line.geometry;\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n    return this;\n  }\n}\nLineGeometry.prototype.isLineGeometry = true;\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n}\nLine2.prototype.isLine2 = true;\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };","map":{"version":3,"names":["Box3","BufferGeometry","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","ShaderLib","ShaderMaterial","UniformsLib","UniformsUtils","Vector2","Line3","MathUtils","Matrix4","Mesh","Vector4","THREE$2","window","THREE","setAttributeFn$1","setAttribute","_box$1","_vector","LineSegmentsGeometry","constructor","type","positions","uvs","index","setIndex","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegments","isGeometry","console","error","isBufferGeometry","setFromBufferAttribute","union","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","toJSON","applyMatrix","warn","prototype","isLineSegmentsGeometry","THREE$1","line","worldUnits","value","linewidth","resolution","dashScale","dashSize","dashOffset","gapSize","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","defines","WORLD_UNITS","dashed","Boolean","USE_DASH","opacity","copy","alphaToCoverage","ALPHA_TO_COVERAGE","extensions","derivatives","setValues","isLineMaterial","setAttributeFn","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","LineSegments2","material","random","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","raycaster","intersects","camera","threshold","params","Line2","ray","projectionMatrix","matrixWorld","lineWidth","near","ssMaxWidth","width","height","distanceToSphere","distanceToPoint","origin","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","intersectsSphere","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2","LineGeometry","length","points","fromLine","isLineGeometry","isLine2"],"sources":["C:/Users/INSP 5430 I5/OneDrive/Desktop/mernstack/front-end/node_modules/three-fatline/dist/three-fatline.mjs"],"sourcesContent":["import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Vector2, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n};\n\n// support multiple method names for backwards threejs compatibility\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nconst _box$1 = new THREE$2.Box3();\nconst _vector = new THREE$2.Vector3();\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box$1.setFromBufferAttribute(end);\n      this.boundingBox.union(_box$1);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n  toJSON() {// todo\n  }\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n}\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n}\nLineMaterial.prototype.isLineMaterial = true;\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nconst _start = new THREE.Vector3();\nconst _end = new THREE.Vector3();\nconst _start4 = new THREE.Vector4();\nconst _end4 = new THREE.Vector4();\nconst _ssOrigin = new THREE.Vector4();\nconst _ssOrigin3 = new THREE.Vector3();\nconst _mvMatrix = new THREE.Matrix4();\nconst _line = new THREE.Line3();\nconst _closestPoint = new THREE.Vector3();\nconst _box = new THREE.Box3();\nconst _sphere = new THREE.Sphere();\nconst _clipToWorldVector = new THREE.Vector4();\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n    _ssOrigin.applyMatrix4(projectionMatrix);\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n    _ssOrigin3.copy(_ssOrigin);\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n      _end4.fromBufferAttribute(instanceEnd, i);\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n        _end4.lerp(_start4, t);\n      } // clip space\n\n      _start4.applyMatrix4(projectionMatrix);\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n      _start4.multiplyScalar(1 / _start4.w);\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n      _line.start.z = 0;\n      _line.end.copy(_end4);\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n        _line.end.fromBufferAttribute(instanceEnd, i);\n        _line.start.applyMatrix4(matrixWorld);\n        _line.end.applyMatrix4(matrixWorld);\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n}\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n    super.setPositions(points);\n    return this;\n  }\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n    super.setColors(colors);\n    return this;\n  }\n  fromLine(line) {\n    var geometry = line.geometry;\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n    return this;\n  }\n}\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n}\nLine2.prototype.isLine2 = true;\n\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };\n"],"mappings":"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CAAC;AAAA,EAC1C;EACAZ,SAAS;EACTC,cAAc;EACdC,WAAW;EACXC,aAAa;EACbC;AACF,CAAC;AACD0E,OAAO,CAAC5E,WAAW,CAAC6E,IAAI,GAAG;EACzBC,UAAU,EAAE;IACVC,KAAK,EAAE;EACT,CAAC;EACDC,SAAS,EAAE;IACTD,KAAK,EAAE;EACT,CAAC;EACDE,UAAU,EAAE;IACVF,KAAK,EAAE,IAAIH,OAAO,CAAC1E,OAAO,CAAC,CAAC,EAAE,CAAC;EACjC,CAAC;EACDgF,SAAS,EAAE;IACTH,KAAK,EAAE;EACT,CAAC;EACDI,QAAQ,EAAE;IACRJ,KAAK,EAAE;EACT,CAAC;EACDK,UAAU,EAAE;IACVL,KAAK,EAAE;EACT,CAAC;EACDM,OAAO,EAAE;IACPN,KAAK,EAAE;EACT,CAAC,CAAC;AACJ,CAAC;AACDH,OAAO,CAAC9E,SAAS,CAAC,MAAM,CAAC,GAAG;EAC1BwF,QAAQ,EAAEV,OAAO,CAAC3E,aAAa,CAACsF,KAAK,CAAC,CAACX,OAAO,CAAC5E,WAAW,CAACwF,MAAM,EAAEZ,OAAO,CAAC5E,WAAW,CAACyF,GAAG,EAAEb,OAAO,CAAC5E,WAAW,CAAC6E,IAAI,CAAC,CAAC;EACtHa,YAAY,EAAE;EACd;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,cAAc,EAAE;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAMC,YAAY,SAAShB,OAAO,CAAC7E,cAAc,CAAC;EAChDiB,WAAWA,CAAC6E,UAAU,EAAE;IACtB,KAAK,CAAC;MACJ5E,IAAI,EAAE,cAAc;MACpBqE,QAAQ,EAAEV,OAAO,CAAC3E,aAAa,CAAC6F,KAAK,CAAClB,OAAO,CAAC9E,SAAS,CAAC,MAAM,CAAC,CAACwF,QAAQ,CAAC;MACzEI,YAAY,EAAEd,OAAO,CAAC9E,SAAS,CAAC,MAAM,CAAC,CAAC4F,YAAY;MACpDC,cAAc,EAAEf,OAAO,CAAC9E,SAAS,CAAC,MAAM,CAAC,CAAC6F,cAAc;MACxDI,QAAQ,EAAE,IAAI,CAAC;IACjB,CAAC,CAAC;IACFC,MAAM,CAACC,gBAAgB,CAAC,IAAI,EAAE;MAC5BC,KAAK,EAAE;QACLC,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACe,OAAO,CAACtB,KAAK;QACpC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACe,OAAO,CAACtB,KAAK,GAAGA,KAAK;QACrC;MACF,CAAC;MACDD,UAAU,EAAE;QACVqB,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,aAAa,IAAI,IAAI,CAACG,OAAO;QACtC,CAAC;QACDD,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAIA,KAAK,KAAK,IAAI,EAAE;YAClB,IAAI,CAACwB,OAAO,CAACC,WAAW,GAAG,EAAE;UAC/B,CAAC,MAAM;YACL,OAAO,IAAI,CAACD,OAAO,CAACC,WAAW;UACjC;QACF;MACF,CAAC;MACDxB,SAAS,EAAE;QACTmB,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACN,SAAS,CAACD,KAAK;QACtC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACN,SAAS,CAACD,KAAK,GAAGA,KAAK;QACvC;MACF,CAAC;MACD0B,MAAM,EAAE;QACNN,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAOM,OAAO,CAAC,UAAU,IAAI,IAAI,CAACH,OAAO,CAAC;QAC5C,CAAC;QACDD,GAAGA,CAACvB,KAAK,EAAE;UACT,IAAI2B,OAAO,CAAC3B,KAAK,CAAC,KAAK2B,OAAO,CAAC,UAAU,IAAI,IAAI,CAACH,OAAO,CAAC,EAAE;YAC1D,IAAI,CAACzE,WAAW,GAAG,IAAI;UACzB;UACA,IAAIiD,KAAK,KAAK,IAAI,EAAE;YAClB,IAAI,CAACwB,OAAO,CAACI,QAAQ,GAAG,EAAE;UAC5B,CAAC,MAAM;YACL,OAAO,IAAI,CAACJ,OAAO,CAACI,QAAQ;UAC9B;QACF;MACF,CAAC;MACDzB,SAAS,EAAE;QACTiB,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACJ,SAAS,CAACH,KAAK;QACtC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACJ,SAAS,CAACH,KAAK,GAAGA,KAAK;QACvC;MACF,CAAC;MACDI,QAAQ,EAAE;QACRgB,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACH,QAAQ,CAACJ,KAAK;QACrC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACH,QAAQ,CAACJ,KAAK,GAAGA,KAAK;QACtC;MACF,CAAC;MACDK,UAAU,EAAE;QACVe,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACF,UAAU,CAACL,KAAK;QACvC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACF,UAAU,CAACL,KAAK,GAAGA,KAAK;QACxC;MACF,CAAC;MACDM,OAAO,EAAE;QACPc,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACD,OAAO,CAACN,KAAK;QACpC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACD,OAAO,CAACN,KAAK,GAAGA,KAAK;QACrC;MACF,CAAC;MACD6B,OAAO,EAAE;QACPT,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACsB,OAAO,CAAC7B,KAAK;QACpC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACsB,OAAO,CAAC7B,KAAK,GAAGA,KAAK;QACrC;MACF,CAAC;MACDE,UAAU,EAAE;QACVkB,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAO,IAAI,CAACd,QAAQ,CAACL,UAAU,CAACF,KAAK;QACvC,CAAC;QACDuB,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI,CAACO,QAAQ,CAACL,UAAU,CAACF,KAAK,CAAC8B,IAAI,CAAC9B,KAAK,CAAC;QAC5C;MACF,CAAC;MACD+B,eAAe,EAAE;QACfX,UAAU,EAAE,IAAI;QAChBC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACf,OAAOM,OAAO,CAAC,mBAAmB,IAAI,IAAI,CAACH,OAAO,CAAC;QACrD,CAAC;QACDD,GAAG,EAAE,SAAAA,CAAUvB,KAAK,EAAE;UACpB,IAAI2B,OAAO,CAAC3B,KAAK,CAAC,KAAK2B,OAAO,CAAC,mBAAmB,IAAI,IAAI,CAACH,OAAO,CAAC,EAAE;YACnE,IAAI,CAACzE,WAAW,GAAG,IAAI;UACzB;UACA,IAAIiD,KAAK,KAAK,IAAI,EAAE;YAClB,IAAI,CAACwB,OAAO,CAACQ,iBAAiB,GAAG,EAAE;YACnC,IAAI,CAACC,UAAU,CAACC,WAAW,GAAG,IAAI;UACpC,CAAC,MAAM;YACL,OAAO,IAAI,CAACV,OAAO,CAACQ,iBAAiB;YACrC,IAAI,CAACC,UAAU,CAACC,WAAW,GAAG,KAAK;UACrC;QACF;MACF;IACF,CAAC,CAAC;IACF,IAAI,CAACC,SAAS,CAACrB,UAAU,CAAC;EAC5B;AACF;AACAD,YAAY,CAAClB,SAAS,CAACyC,cAAc,GAAG,IAAI;AAE5C,MAAMzG,KAAK,GAAGD,MAAM,CAACC,KAAK,GAAGD,MAAM,CAACC,KAAK,CAAC;AAAA,EACxC;EACArB,IAAI;EACJC,cAAc;EACdG,0BAA0B;EAC1BC,0BAA0B;EAC1BS,KAAK;EACLC,SAAS;EACTC,OAAO;EACPC,IAAI;EACJX,MAAM;EACNC,OAAO;EACPW;AACF,CAAC;;AAED;AACA,IAAI6G,cAAc,GAAG,IAAI1G,KAAK,CAACpB,cAAc,CAAC,CAAC,CAACsB,YAAY,GAAG,cAAc,GAAG,cAAc;AAC9F,MAAMyG,MAAM,GAAG,IAAI3G,KAAK,CAACd,OAAO,CAAC,CAAC;AAClC,MAAM0H,IAAI,GAAG,IAAI5G,KAAK,CAACd,OAAO,CAAC,CAAC;AAChC,MAAM2H,OAAO,GAAG,IAAI7G,KAAK,CAACH,OAAO,CAAC,CAAC;AACnC,MAAMiH,KAAK,GAAG,IAAI9G,KAAK,CAACH,OAAO,CAAC,CAAC;AACjC,MAAMkH,SAAS,GAAG,IAAI/G,KAAK,CAACH,OAAO,CAAC,CAAC;AACrC,MAAMmH,UAAU,GAAG,IAAIhH,KAAK,CAACd,OAAO,CAAC,CAAC;AACtC,MAAM+H,SAAS,GAAG,IAAIjH,KAAK,CAACL,OAAO,CAAC,CAAC;AACrC,MAAMuH,KAAK,GAAG,IAAIlH,KAAK,CAACP,KAAK,CAAC,CAAC;AAC/B,MAAM0H,aAAa,GAAG,IAAInH,KAAK,CAACd,OAAO,CAAC,CAAC;AACzC,MAAMkI,IAAI,GAAG,IAAIpH,KAAK,CAACrB,IAAI,CAAC,CAAC;AAC7B,MAAM0I,OAAO,GAAG,IAAIrH,KAAK,CAACf,MAAM,CAAC,CAAC;AAClC,MAAMqI,kBAAkB,GAAG,IAAItH,KAAK,CAACH,OAAO,CAAC,CAAC;AAC9C,MAAM0H,aAAa,SAASvH,KAAK,CAACJ,IAAI,CAAC;EACrCU,WAAWA,CAAC8B,QAAQ,GAAG,IAAI/B,oBAAoB,CAAC,CAAC,EAAEmH,QAAQ,GAAG,IAAItC,YAAY,CAAC;IAC7EM,KAAK,EAAEjC,IAAI,CAACkE,MAAM,CAAC,CAAC,GAAG;EACzB,CAAC,CAAC,EAAE;IACF,KAAK,CAACrF,QAAQ,EAAEoF,QAAQ,CAAC;IACzB,IAAI,CAACjH,IAAI,GAAG,eAAe;EAC7B,CAAC,CAAC;;EAEFmH,oBAAoBA,CAAA,EAAG;IACrB,MAAMtF,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMpB,aAAa,GAAGoB,QAAQ,CAACrB,UAAU,CAACC,aAAa;IACvD,MAAME,WAAW,GAAGkB,QAAQ,CAACrB,UAAU,CAACG,WAAW;IACnD,MAAMyG,aAAa,GAAG,IAAI/F,YAAY,CAAC,CAAC,GAAGZ,aAAa,CAACqC,KAAK,CAAC;IAC/D,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEyE,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG7G,aAAa,CAACqC,KAAK,EAAEF,CAAC,GAAG0E,CAAC,EAAE1E,CAAC,EAAE,EAAEyE,CAAC,IAAI,CAAC,EAAE;MAClEjB,MAAM,CAACrD,mBAAmB,CAACtC,aAAa,EAAEmC,CAAC,CAAC;MAC5CyD,IAAI,CAACtD,mBAAmB,CAACpC,WAAW,EAAEiC,CAAC,CAAC;MACxCwE,aAAa,CAACC,CAAC,CAAC,GAAGA,CAAC,KAAK,CAAC,GAAG,CAAC,GAAGD,aAAa,CAACC,CAAC,GAAG,CAAC,CAAC;MACrDD,aAAa,CAACC,CAAC,GAAG,CAAC,CAAC,GAAGD,aAAa,CAACC,CAAC,CAAC,GAAGjB,MAAM,CAACmB,UAAU,CAAClB,IAAI,CAAC;IACnE;IACA,MAAMmB,sBAAsB,GAAG,IAAI/H,KAAK,CAACjB,0BAA0B,CAAC4I,aAAa,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;IAE1FvF,QAAQ,CAACsE,cAAc,CAAC,CAAC,uBAAuB,EAAE,IAAI1G,KAAK,CAAChB,0BAA0B,CAAC+I,sBAAsB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;IAEvH3F,QAAQ,CAACsE,cAAc,CAAC,CAAC,qBAAqB,EAAE,IAAI1G,KAAK,CAAChB,0BAA0B,CAAC+I,sBAAsB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;IAErH,OAAO,IAAI;EACb;EACAC,OAAOA,CAACC,SAAS,EAAEC,UAAU,EAAE;IAC7B,IAAID,SAAS,CAACE,MAAM,KAAK,IAAI,EAAE;MAC7BxF,OAAO,CAACC,KAAK,CAAC,8FAA8F,CAAC;IAC/G;IACA,MAAMwF,SAAS,GAAGH,SAAS,CAACI,MAAM,CAACC,KAAK,KAAKnH,SAAS,GAAG8G,SAAS,CAACI,MAAM,CAACC,KAAK,CAACF,SAAS,IAAI,CAAC,GAAG,CAAC;IAClG,MAAMG,GAAG,GAAGN,SAAS,CAACM,GAAG;IACzB,MAAMJ,MAAM,GAAGF,SAAS,CAACE,MAAM;IAC/B,MAAMK,gBAAgB,GAAGL,MAAM,CAACK,gBAAgB;IAChD,MAAMC,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMrG,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMoF,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMjD,UAAU,GAAGiD,QAAQ,CAACjD,UAAU;IACtC,MAAMmE,SAAS,GAAGlB,QAAQ,CAAClD,SAAS,GAAG8D,SAAS;IAChD,MAAMpH,aAAa,GAAGoB,QAAQ,CAACrB,UAAU,CAACC,aAAa;IACvD,MAAME,WAAW,GAAGkB,QAAQ,CAACrB,UAAU,CAACG,WAAW,CAAC,CAAC;;IAErD,MAAMyH,IAAI,GAAG,CAACR,MAAM,CAACQ,IAAI,CAAC,CAAC;IAC3B;;IAEA,MAAMC,UAAU,GAAG,GAAG,GAAGrF,IAAI,CAACC,GAAG,CAACkF,SAAS,GAAGnE,UAAU,CAACsE,KAAK,EAAEH,SAAS,GAAGnE,UAAU,CAACuE,MAAM,CAAC,CAAC,CAAC;IAChG;;IAEA,IAAI1G,QAAQ,CAACb,cAAc,KAAK,IAAI,EAAE;MACpCa,QAAQ,CAACZ,qBAAqB,CAAC,CAAC;IAClC;IACA6F,OAAO,CAAClB,IAAI,CAAC/D,QAAQ,CAACb,cAAc,CAAC,CAACX,YAAY,CAAC6H,WAAW,CAAC;IAC/D,MAAMM,gBAAgB,GAAGxF,IAAI,CAACC,GAAG,CAAC2E,MAAM,CAACQ,IAAI,EAAEtB,OAAO,CAAC2B,eAAe,CAACT,GAAG,CAACU,MAAM,CAAC,CAAC,CAAC,CAAC;;IAErF3B,kBAAkB,CAAC1B,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAACmD,gBAAgB,EAAE,GAAG,CAAC,CAACnI,YAAY,CAACuH,MAAM,CAACK,gBAAgB,CAAC;IAC1FlB,kBAAkB,CAAC4B,cAAc,CAAC,GAAG,GAAG5B,kBAAkB,CAAC6B,CAAC,CAAC;IAC7D7B,kBAAkB,CAAC1G,YAAY,CAACuH,MAAM,CAACiB,uBAAuB,CAAC,CAAC,CAAC;;IAEjE,MAAMC,YAAY,GAAG9F,IAAI,CAAC+F,GAAG,CAACV,UAAU,GAAGtB,kBAAkB,CAAC6B,CAAC,CAAC,GAAG,GAAG;IACtE9B,OAAO,CAAC3D,MAAM,IAAI2F,YAAY;IAC9B,IAAIpB,SAAS,CAACM,GAAG,CAACgB,gBAAgB,CAAClC,OAAO,CAAC,KAAK,KAAK,EAAE;MACrD;IACF,CAAC,CAAC;IACF;;IAEA,IAAIjF,QAAQ,CAACf,WAAW,KAAK,IAAI,EAAE;MACjCe,QAAQ,CAACd,kBAAkB,CAAC,CAAC;IAC/B;IACA8F,IAAI,CAACjB,IAAI,CAAC/D,QAAQ,CAACf,WAAW,CAAC,CAACT,YAAY,CAAC6H,WAAW,CAAC;IACzD,MAAMe,aAAa,GAAGjG,IAAI,CAACC,GAAG,CAAC2E,MAAM,CAACQ,IAAI,EAAEvB,IAAI,CAAC4B,eAAe,CAACT,GAAG,CAACU,MAAM,CAAC,CAAC,CAAC,CAAC;;IAE/E3B,kBAAkB,CAAC1B,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC4D,aAAa,EAAE,GAAG,CAAC,CAAC5I,YAAY,CAACuH,MAAM,CAACK,gBAAgB,CAAC;IACvFlB,kBAAkB,CAAC4B,cAAc,CAAC,GAAG,GAAG5B,kBAAkB,CAAC6B,CAAC,CAAC;IAC7D7B,kBAAkB,CAAC1G,YAAY,CAACuH,MAAM,CAACiB,uBAAuB,CAAC,CAAC,CAAC;;IAEjE,MAAMK,SAAS,GAAGlG,IAAI,CAAC+F,GAAG,CAACV,UAAU,GAAGtB,kBAAkB,CAAC6B,CAAC,CAAC,GAAG,GAAG;IACnE/B,IAAI,CAAC5D,GAAG,CAACkG,CAAC,IAAID,SAAS;IACvBrC,IAAI,CAAC5D,GAAG,CAACmG,CAAC,IAAIF,SAAS;IACvBrC,IAAI,CAAC5D,GAAG,CAACoG,CAAC,IAAIH,SAAS;IACvBrC,IAAI,CAACyC,GAAG,CAACH,CAAC,IAAID,SAAS;IACvBrC,IAAI,CAACyC,GAAG,CAACF,CAAC,IAAIF,SAAS;IACvBrC,IAAI,CAACyC,GAAG,CAACD,CAAC,IAAIH,SAAS;IACvB,IAAIxB,SAAS,CAACM,GAAG,CAACuB,aAAa,CAAC1C,IAAI,CAAC,KAAK,KAAK,EAAE;MAC/C;IACF,CAAC,CAAC;IACF;IACA;IACA;;IAEAmB,GAAG,CAACwB,EAAE,CAAC,CAAC,EAAEhD,SAAS,CAAC,CAAC,CAAC;;IAEtBA,SAAS,CAACoC,CAAC,GAAG,CAAC;IACfpC,SAAS,CAACnG,YAAY,CAACuH,MAAM,CAAC6B,kBAAkB,CAAC;IACjDjD,SAAS,CAACnG,YAAY,CAAC4H,gBAAgB,CAAC;IACxCzB,SAAS,CAACmC,cAAc,CAAC,CAAC,GAAGnC,SAAS,CAACoC,CAAC,CAAC,CAAC,CAAC;;IAE3CpC,SAAS,CAAC2C,CAAC,IAAInF,UAAU,CAACmF,CAAC,GAAG,CAAC;IAC/B3C,SAAS,CAAC4C,CAAC,IAAIpF,UAAU,CAACoF,CAAC,GAAG,CAAC;IAC/B5C,SAAS,CAAC6C,CAAC,GAAG,CAAC;IACf5C,UAAU,CAACb,IAAI,CAACY,SAAS,CAAC;IAC1BE,SAAS,CAACgD,gBAAgB,CAAC9B,MAAM,CAAC6B,kBAAkB,EAAEvB,WAAW,CAAC;IAClE,KAAK,IAAItF,CAAC,GAAG,CAAC,EAAE0E,CAAC,GAAG7G,aAAa,CAACqC,KAAK,EAAEF,CAAC,GAAG0E,CAAC,EAAE1E,CAAC,EAAE,EAAE;MACnD0D,OAAO,CAACvD,mBAAmB,CAACtC,aAAa,EAAEmC,CAAC,CAAC;MAC7C2D,KAAK,CAACxD,mBAAmB,CAACpC,WAAW,EAAEiC,CAAC,CAAC;MACzC0D,OAAO,CAACsC,CAAC,GAAG,CAAC;MACbrC,KAAK,CAACqC,CAAC,GAAG,CAAC,CAAC,CAAC;;MAEbtC,OAAO,CAACjG,YAAY,CAACqG,SAAS,CAAC;MAC/BH,KAAK,CAAClG,YAAY,CAACqG,SAAS,CAAC,CAAC,CAAC;;MAE/B,IAAIiD,kBAAkB,GAAGrD,OAAO,CAAC+C,CAAC,GAAGjB,IAAI,IAAI7B,KAAK,CAAC8C,CAAC,GAAGjB,IAAI;MAC3D,IAAIuB,kBAAkB,EAAE;QACtB;MACF,CAAC,CAAC;;MAEF,IAAIrD,OAAO,CAAC+C,CAAC,GAAGjB,IAAI,EAAE;QACpB,MAAMwB,SAAS,GAAGtD,OAAO,CAAC+C,CAAC,GAAG9C,KAAK,CAAC8C,CAAC;QACrC,MAAMQ,CAAC,GAAG,CAACvD,OAAO,CAAC+C,CAAC,GAAGjB,IAAI,IAAIwB,SAAS;QACxCtD,OAAO,CAACwD,IAAI,CAACvD,KAAK,EAAEsD,CAAC,CAAC;MACxB,CAAC,MAAM,IAAItD,KAAK,CAAC8C,CAAC,GAAGjB,IAAI,EAAE;QACzB,MAAMwB,SAAS,GAAGrD,KAAK,CAAC8C,CAAC,GAAG/C,OAAO,CAAC+C,CAAC;QACrC,MAAMQ,CAAC,GAAG,CAACtD,KAAK,CAAC8C,CAAC,GAAGjB,IAAI,IAAIwB,SAAS;QACtCrD,KAAK,CAACuD,IAAI,CAACxD,OAAO,EAAEuD,CAAC,CAAC;MACxB,CAAC,CAAC;;MAEFvD,OAAO,CAACjG,YAAY,CAAC4H,gBAAgB,CAAC;MACtC1B,KAAK,CAAClG,YAAY,CAAC4H,gBAAgB,CAAC,CAAC,CAAC;;MAEtC3B,OAAO,CAACqC,cAAc,CAAC,CAAC,GAAGrC,OAAO,CAACsC,CAAC,CAAC;MACrCrC,KAAK,CAACoC,cAAc,CAAC,CAAC,GAAGpC,KAAK,CAACqC,CAAC,CAAC,CAAC,CAAC;;MAEnCtC,OAAO,CAAC6C,CAAC,IAAInF,UAAU,CAACmF,CAAC,GAAG,CAAC;MAC7B7C,OAAO,CAAC8C,CAAC,IAAIpF,UAAU,CAACoF,CAAC,GAAG,CAAC;MAC7B7C,KAAK,CAAC4C,CAAC,IAAInF,UAAU,CAACmF,CAAC,GAAG,CAAC;MAC3B5C,KAAK,CAAC6C,CAAC,IAAIpF,UAAU,CAACoF,CAAC,GAAG,CAAC,CAAC,CAAC;;MAE7BzC,KAAK,CAACpG,KAAK,CAACqF,IAAI,CAACU,OAAO,CAAC;MACzBK,KAAK,CAACpG,KAAK,CAAC8I,CAAC,GAAG,CAAC;MACjB1C,KAAK,CAACjG,GAAG,CAACkF,IAAI,CAACW,KAAK,CAAC;MACrBI,KAAK,CAACjG,GAAG,CAAC2I,CAAC,GAAG,CAAC,CAAC,CAAC;;MAEjB,MAAMU,KAAK,GAAGpD,KAAK,CAACqD,4BAA4B,CAACvD,UAAU,EAAE,IAAI,CAAC;MAClEE,KAAK,CAAC6C,EAAE,CAACO,KAAK,EAAEnD,aAAa,CAAC,CAAC,CAAC;;MAEhC,MAAMqD,IAAI,GAAGxK,KAAK,CAACN,SAAS,CAAC2K,IAAI,CAACxD,OAAO,CAAC+C,CAAC,EAAE9C,KAAK,CAAC8C,CAAC,EAAEU,KAAK,CAAC;MAC5D,MAAMG,aAAa,GAAGD,IAAI,IAAI,CAAC,CAAC,IAAIA,IAAI,IAAI,CAAC;MAC7C,MAAME,QAAQ,GAAG1D,UAAU,CAACc,UAAU,CAACX,aAAa,CAAC,GAAGuB,SAAS,GAAG,GAAG;MACvE,IAAI+B,aAAa,IAAIC,QAAQ,EAAE;QAC7BxD,KAAK,CAACpG,KAAK,CAACwC,mBAAmB,CAACtC,aAAa,EAAEmC,CAAC,CAAC;QACjD+D,KAAK,CAACjG,GAAG,CAACqC,mBAAmB,CAACpC,WAAW,EAAEiC,CAAC,CAAC;QAC7C+D,KAAK,CAACpG,KAAK,CAACF,YAAY,CAAC6H,WAAW,CAAC;QACrCvB,KAAK,CAACjG,GAAG,CAACL,YAAY,CAAC6H,WAAW,CAAC;QACnC,MAAMkC,WAAW,GAAG,IAAI3K,KAAK,CAACd,OAAO,CAAC,CAAC;QACvC,MAAM0L,KAAK,GAAG,IAAI5K,KAAK,CAACd,OAAO,CAAC,CAAC;QACjCqJ,GAAG,CAACsC,mBAAmB,CAAC3D,KAAK,CAACpG,KAAK,EAAEoG,KAAK,CAACjG,GAAG,EAAE2J,KAAK,EAAED,WAAW,CAAC;QACnEzC,UAAU,CAAC4C,IAAI,CAAC;UACdF,KAAK,EAAEA,KAAK;UACZD,WAAW,EAAEA,WAAW;UACxBI,QAAQ,EAAExC,GAAG,CAACU,MAAM,CAACnB,UAAU,CAAC8C,KAAK,CAAC;UACtCI,MAAM,EAAE,IAAI;UACZC,IAAI,EAAE,IAAI;UACVC,SAAS,EAAE/H,CAAC;UACZgI,EAAE,EAAE,IAAI;UACRC,GAAG,EAAE;QACP,CAAC,CAAC;MACJ;IACF;EACF;AACF;AACA7D,aAAa,CAACvD,SAAS,CAACuD,aAAa,GAAG,IAAI;AAE5C,MAAM8D,YAAY,SAAShL,oBAAoB,CAAC;EAC9CC,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,IAAI,GAAG,cAAc;EAC5B;EACAkB,YAAYA,CAACC,KAAK,EAAE;IAClB;IACA,IAAI4J,MAAM,GAAG5J,KAAK,CAAC4J,MAAM,GAAG,CAAC;IAC7B,IAAIC,MAAM,GAAG,IAAI3J,YAAY,CAAC,CAAC,GAAG0J,MAAM,CAAC;IACzC,KAAK,IAAInI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmI,MAAM,EAAEnI,CAAC,IAAI,CAAC,EAAE;MAClCoI,MAAM,CAAC,CAAC,GAAGpI,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,CAAC;MACxBoI,MAAM,CAAC,CAAC,GAAGpI,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChCoI,MAAM,CAAC,CAAC,GAAGpI,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChCoI,MAAM,CAAC,CAAC,GAAGpI,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChCoI,MAAM,CAAC,CAAC,GAAGpI,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChCoI,MAAM,CAAC,CAAC,GAAGpI,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;IAClC;IACA,KAAK,CAAC1B,YAAY,CAAC8J,MAAM,CAAC;IAC1B,OAAO,IAAI;EACb;EACAvJ,SAASA,CAACN,KAAK,EAAE;IACf;IACA,IAAI4J,MAAM,GAAG5J,KAAK,CAAC4J,MAAM,GAAG,CAAC;IAC7B,IAAIrJ,MAAM,GAAG,IAAIL,YAAY,CAAC,CAAC,GAAG0J,MAAM,CAAC;IACzC,KAAK,IAAInI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmI,MAAM,EAAEnI,CAAC,IAAI,CAAC,EAAE;MAClClB,MAAM,CAAC,CAAC,GAAGkB,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,CAAC;MACxBlB,MAAM,CAAC,CAAC,GAAGkB,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChClB,MAAM,CAAC,CAAC,GAAGkB,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChClB,MAAM,CAAC,CAAC,GAAGkB,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChClB,MAAM,CAAC,CAAC,GAAGkB,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;MAChClB,MAAM,CAAC,CAAC,GAAGkB,CAAC,GAAG,CAAC,CAAC,GAAGzB,KAAK,CAACyB,CAAC,GAAG,CAAC,CAAC;IAClC;IACA,KAAK,CAACnB,SAAS,CAACC,MAAM,CAAC;IACvB,OAAO,IAAI;EACb;EACAuJ,QAAQA,CAACrH,IAAI,EAAE;IACb,IAAI/B,QAAQ,GAAG+B,IAAI,CAAC/B,QAAQ;IAC5B,IAAIA,QAAQ,CAACM,UAAU,EAAE;MACvBC,OAAO,CAACC,KAAK,CAAC,mFAAmF,CAAC;MAClG;IACF,CAAC,MAAM,IAAIR,QAAQ,CAACS,gBAAgB,EAAE;MACpC,IAAI,CAACpB,YAAY,CAACW,QAAQ,CAACrB,UAAU,CAACsB,QAAQ,CAACX,KAAK,CAAC,CAAC,CAAC;IACzD,CAAC,CAAC;;IAEF,OAAO,IAAI;EACb;AACF;AACA2J,YAAY,CAACrH,SAAS,CAACyH,cAAc,GAAG,IAAI;AAE5C,MAAMnD,KAAK,SAASf,aAAa,CAAC;EAChCjH,WAAWA,CAAC8B,QAAQ,GAAG,IAAIiJ,YAAY,CAAC,CAAC,EAAE7D,QAAQ,GAAG,IAAItC,YAAY,CAAC;IACrEM,KAAK,EAAEjC,IAAI,CAACkE,MAAM,CAAC,CAAC,GAAG;EACzB,CAAC,CAAC,EAAE;IACF,KAAK,CAACrF,QAAQ,EAAEoF,QAAQ,CAAC;IACzB,IAAI,CAACjH,IAAI,GAAG,OAAO;EACrB;AACF;AACA+H,KAAK,CAACtE,SAAS,CAAC0H,OAAO,GAAG,IAAI;AAE9B,SAASpD,KAAK,EAAE+C,YAAY,EAAEnG,YAAY,EAAEqC,aAAa,EAAElH,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}